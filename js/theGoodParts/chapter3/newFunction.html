<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    //es6对象的新增方法
    <script>
        //1.Object.is() JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。
        console.log(Object.is('foo', 'foo')) // true
        console.log(Object.is({}, {})) // false
        
        console.log(+0 === -0)// true
        console.log(NaN === NaN)// false

        console.log(Object.is(+0, -0))// false
        console.log(Object.is(NaN, NaN))// true

        //2.Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
        //Object.assign()方法的第一个参数是目标对象，后面的参数都是源对象。
        // const target = { a : 1 };
        // const source1 = { b: 2 };
        // const source2 = { c : 3 };
        // Object.assign(target, source1, source2);
        // console.log(target);// {a:1, b:2, c:3}
        
        //如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
        const target = { a: 1, b: 1 };
        const source1 = { b: 2, c: 2 };
        const source2 = { c: 3 };
        Object.assign(target, source1, source2);
        console.log(target)  // {a:1, b:2, c:3}

        //如果该参数不是对象，则会先转成对象，然后返回。
        console.log(typeof Object.assign(2))  // "object"
        //由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。
        Object.assign(undefined) // 报错
        Object.assign(null) // 报错
        //如果undefined和null不在首参数，就不会报错。
        let obj = {a: 1};
        Object.assign(obj, undefined) === obj // true
        Object.assign(obj, null) === obj // true
        //其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。
        const v1 = 'abc';
        const v2 = true;
        const v3 = 10;
        const obj = Object.assign({}, v1, v2, v3);
        console.log(obj); // { "0": "a", "1": "b", "2": "c" }
        //这是因为只有字符串的包装对象，会产生可枚举属性。
        Object(true) // {[[PrimitiveValue]]: true}
        Object(10)  //  {[[PrimitiveValue]]: 10}
        Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}
        //还有很多  不想写了  看这里  第二个方法用法太多了https://es6.ruanyifeng.com/#docs/object-methods
        

        //Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象
        const obj = {
        foo: 123,
        get bar() { return 'abc' }
        };

        Object.getOwnPropertyDescriptors(obj)
        // { foo:
        //    { value: 123,
        //      writable: true,
        //      enumerable: true,
        //      configurable: true },
        //   bar:
        //    { get: [Function: get bar],
        //      set: undefined,
        //      enumerable: true,
        //      configurable: true } }
        
        //该方法的实现非常容易。
        function getOwnPropertyDescriptors(obj) {
        const result = {};
        for (let key of Reflect.ownKeys(obj)) {
            result[key] = Object.getOwnPropertyDescriptor(obj, key);
        }
        return result;
        }

        //__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()
        // es5 的写法
        const obj = {
        method: function() { }
        };
        obj.__proto__ = someOtherObj;
        // es6 的写法
        var obj = Object.create(someOtherObj);
        obj.method = function() {  };

        //Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。
        // 格式
        Object.setPrototypeOf(object, prototype)
        // 用法
        const o = Object.setPrototypeOf({}, null);

        //Object.getPrototypeOf()与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。











    </script>
</body>
</html>