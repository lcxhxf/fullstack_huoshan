<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>函数</title>
</head>

<body>
    <script>
        // var sum = function (a, b) {
        //     return a + b
        // }

        //方法调用模式
        // var obj ={
        //     value:1,
        //     showValue:function(){
        //         console.log('value:',this.value);
        //     }
        // }
        // obj.showValue()// value:1

        // var add = function (a, b) {
        //     return a + b;
        // }
        // add(3, 4);  //7
        // window.add(3, 4);  //7
        // 这种this被绑定到全局对象（window）。
        // 可以理解是window.add(3,4);

        // 函数调用模式
        // var myObj = {
        //     value: 0,
        //     age: 20,
        //     showValue: function () {
        //         console.log('value:', this.value);
        //         var that = this;
        //         var showAge = function () {
        //             // window上没有age，所以是undefined
        //             console.log('这里的this是window ---age:', this.age);  // undefined
        //             console.log('age:', that.age);  // 20
        //         }
        //         showAge();
        //     }
        // }
        // myObj.showValue();  // value: 0 这里的this是window ---age: undefined age: 20

        //构造器调用模式
        //创建一个名为Quo的构造器函数。它构造带有status属性的对象
        // var Quo = function (string) {
        //     this.status = string;
        // }
        // //给Quo的所有实例提供一个名为get_status的公共方法
        // Quo.prototype.get_status = function () {
        //     return this.status;
        // }
        // //构建一个Quo实例
        // var myQuo = new Quo('confused'); // 'confused'

        // // apply调用模式
        // var array = [3, 4];
        // var sum = add.apply(null, array);//sum值为7

        // //构造一个包含status成员的对象。

        // var statusObject = {
        //     status: 'A-OK'
        // };

        // // statusObject 并没有继承来自 Quo.prototype,但我们可以在statusObject 上调
        // //用get_status方法，尽管statusObject并没有一个名为get_status的方法。

        // var status = Quo.prototype.get_status.apply(statusObject);
        // // status 值为'A-OK'

        //构造一个将很多个值相加的函数
        //注意该函数内部定义的变量sum不会与函数外部定义的sum产生冲突。
        //该函数只会看到内部的那个变量。
        // var sum = function () {
        //     vari, sum = 0;
        //     for (i = 0; i < arguments.length; i += 1) {
        //         sum += arguments[i];
        //     }
        //     return sum;
        // };
        // document.writeln(sum(4, 8, 15, 16, 23, 42)); // 108 

        // var add = function (a, b) {
        //     if (typeof a !== 'number' || typeof b !== 'number') {
        //         throw {
        //             name: 'TypeError',
        //             message: 'add needs numbers'
        //         };
        //     }
        //     return a + b;
        // }

        // //构造一个try_it函数，用不正确的方式调用之前的add函数
        // var try_it = function () {
        //     try {
        //         add("seven");
        //     } catch (e) {
        //         document.writeln(e.name + ': ' + e.message);
        //     }
        // }
        // try_it(); //TypeError: add needs numbers


        // Function.prototype.method = function () {
        //     this.prototype[name] = func;
        //     return this;
        // }

        // Function.prototype.methods = function (name, func) {
        //     if (!this.prototype[name]) {
        //         this.prototype[name] = func;
        //     }
        //     return this;
        // }

        <ul class="list">
            <li>0</li>
            <li>1</li>
            <li>2</li>
            <li>3</li>
        </ul>

        //         // 点击相应节点时，显示对应的序号。可以使用闭包来解决。
        //         var add_the_handlers = function () {
        //             var helper = function (i) {
        //                 return function (e) {
        //                     alert(i);
        //                 }
        //             }
        //             var i;
        //             for (i = 0; i < nodes.length; i += 1) {
        //                 nodes[i].onclick = helper(i);
        //             }
        //         }
        // // 扩展 另外可以用let i = 0，或者把nodes类数组转成数组等方案实现。
        // // 闭包特性：1、函数内再嵌套函数，2、内部函数可以调用外层的参数和变量，3、参数和变量不会被垃圾回收机制回收。
        // // 闭包优点 灵活和方便，便于封装。缺点：空间浪费、内存泄露、性能消耗。

        //     String.method('deentityify', function () {
        //         // 字符实体表。它映射字符实体的名字到对应的字符。
        //         var entity = {
        //             quot: '"',
        //             lt: '<',
        //             gt: '>'
        //         };
        //         // 返回 deentityify方法
        //         return function () {
        //             return this.replace(/&([^&;]+);)/g,
        //                 function (a, b) {
        //                     var r = entity[b];
        //                     return typeof r === 'string' ? r : a;
        //                 }
        // };
        //     }());

        var addl = add.curry(1);
        document.writeln(addl(6)); // 7

        Function.method('curry', function () {
            var args = arguments, that = this;
            return function () {
                return that.apply(null, args.concat(arguments));
            };
        });


        // Function.method('curry', function () {
        //     var slice = Array.prototype.slice,
        //         args = slice.apply(arguments),
        //         that = this;
        //     return function () {
        //         return that.apply(null, args.concat(slice.apply(arguments)));
        //     };
        // });
        // 说明：
        // // concat方法
        // var a = [1, 2, 3];
        // document.write(a.concat(4, 5));
        // // slice方法
        // var arr = new Array(3);
        // arr[0] = "George";
        // arr[1] = "John";
        // arr[2] = "Thomas";
        // document.write(arr.slice(1)); // John,Thomas

    </script>
</body>

</html>